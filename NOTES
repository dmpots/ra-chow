=====
note
=====
question:

does splitting critical edges change the splitting of live ranges? for
example look at fmin.i where splitting critical edges makes chow fail
an insertion on multiple defs..

it seems that splitting critical edges can change the number of
interferences in a live range. This happens when the block for the 
split critical edge is added to a live range to extend its range. This
will happen when the live range is split and adds the extra block even
though it is not needed.

L1:
  z
  BRANCH L2 L3
  
L2:
  y
  GOTO L3

L3:
  y
  x
  END

with split critical edges in this case both x and z extend to the
dummy block L4, which increases their interferences. this can happen
with bad splitting (by adding a block when there is no subsequent use
(z) and adding a block before the first use (x)

L1:
  z
  BRANCH L2 L4
  
L2:
  y
  GOTO L3

L4:
  z
  x
  GOTO L3

L3:
  y
  x


=====
note
=====
it makes a big difference where you choose your split point,
otherwise you can end up with a bunch of live units with no uses and
no defs and the whole live range contains these useless units. i think
that is the cause of the "peeling" splitting we saw where it would
peel off on of the live units each time it would split, but that would
not help since it is a useless live unit


=====
note
=====
question:
why are we not putting the loads and stores in the right place? we are
calculating stores by looking at the uses that each def reaches. if it
reaches a use in another live range then we add a store. if it reaches
a use in the same live range that needs a load we add a store.

we compute loads by looking at the predecessor blocks. if the
predecessor is in another live range then we insert a load.

answer:
phi nodes were getting in the way. if a def reaches a use that is a
phi-node it is not a real use. we need to look at the uses that the
phi-node def reaches as well in order to find all the nodes that def
actually reaches.

=====
note
=====
speed up attemtps: 
 + use a set to for interferece "list" so that adding unique values is
 efficent (log n)

 + choose the starting point for the split much better
   - only split starting with a def or a use
   - split starting with an entry point if possible

 + a live range is uncolorable if all the live units where it actually
 has a use or a def have no available registers

 + only need to update interferences for the new and orig lr and those
 live ranges that they interfered with. can be done efficently by
 iterating over the origlr interferences and seeing what they now
 interfere with


=====
note
=====
observation:

it seems that the splitting algorithm can add live units to the split
live range even when there is no point. we split the live range by
looking for a place where it starts with a def or a use and then do a
bfs of the nodes in the origlr from there adding any node that does
not fill up the forbidden register set. now suppose that we don't get
to another use of the live range in any block that we add, this means
that if we allocate this split live range it could tie up all those
blocks even though it serves no purpose to have that register tied up
since there are no uses beyond the first.

I suspect that the priority function is designed to prevent this from
happening, but it is something to watch for.


=====
note
=====
question:

Would it be beneficial to split the BB at register to register copies?



=====
note
=====
Had a problem where a load was inserted for a live range because it
had a predecessor that was not in the live range, but no store was
inserted in any of the other blocks in the live range. Turns out the
load was requested because it was used in a phi-node, but no store was
generated because we were not counting phi-node uses. 

not sure how exactly this should be handeled. need to better figure
out where to insert loads and stores.


=====
note
=====
Need to solve two problems for inserting stores:
1) if the live range contains a def, figure out which blocks in the LR
that def reaches

2) for those blocks that def reaches, check if the successor block is
in the LR
  2.t) if it IS in the LR, then check if it needs a load
    2.t.t) if it does need a load then insert a store
    2.t.f) if it does not need a load then no store needed
  2.f) if it is NOT in the LR then check to see if the LR is live in
  at the successor block (only occurs after a split)
    2.f.t) if it is live in at successor then insert a store
    2.f.f) if it is not live in then no store needed


=========================
performance observation
=========================
Adding a coalesce pass  actually makes the performance decrease a bit
for the ra (Chaitin) code. This is not clear why, though the amount is
so small it is probably not meaningful.

On the other hand a coalesce pass helps me a lot on the order of
40,000 operations.


=================================
next steps
Thu Aug 17 15:20:08 CDT 2006
=================================
1) look at memory usage to see where we can possible free some memory
so that we do not use so much for allocation
2) implement the optimizations of placement of loads and stores.
  + review PRE as basis for the optimization
  + need to understand when this is done in the algorithm. Chow says
  to use it in order to have a more precise measurement of the
  priority function. so perhaps we can compute it as part of computing
  loads and stores, and just mark the load or store as movable, then
  when computing priority we don't have to count the cost???
3) Implement heuristics described in Chow paper for splitting. These
should improve allocation runtime speed. Chow said they did not help
allocation quality.
4) Need a peephole optimizer to take care of ST followed by immediate
LD
5) Figure out why ra does not give correct results on fpppp and seems
to loop forever on doduc (vgjyeh.i)
6) Why does Chaitin beat me so bad? Because he selects better
variables to store or is it something else?
7) Code up an example where the graph is colorable only through a
split. basically make the graph in Fig. 8 of chow's paper.
8) Check to make sure the coalesce pass is actually working
9) Review priority functions and weights given to functions to see
that priorites are computed sensibly.

Places where I think we can improve chow:
1) he uses memory to connect live ranges after he has split them. If
there was a way to notice that a store is loaded into a register in a
successor block then we could just do a register to register copy
rather than a ST/LD.

Possible splitting heruistics
1) don't add blocks if it makes the number of forbidden colors too
great (i.e. more than 1)

=================================
First Comparison
Thu Aug 17 15:24:23 CDT 2006
=================================
First comparison with the Chaitin allocator showed that it outpeformed
my Chow allocator by anywhere from 12%-133% (1.12-2.33 times better).
Brainstormed with Tim for a while about why this was the case. The
main result we thought of was that Chaitin was using a partitioned
register set while chow used a single register set. This means that
my allocator was having a lot more interferences than ra which could
be causing a lot more spilling.  Next steps to attack:

  1) make chow allocator use partitioned register set
  2) take a more detailed look at the code to see what is causing such
  a poor allocation. One identified problem is a ST followed directly
  by a LD.
  3) implement optimized placement of loads and stores





=================================
List of experiments
Thu Aug 17 15:20:46 CDT 2006
=================================
+ Crank the size of a basic block down to 1 and compare the allocation
with Chaitin



