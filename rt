#!/bin/env ruby
require 'fileutils'
require 'benchmark'
require 'optparse'

#function to execute a shell command
def sh(cmd)
  `#{cmd}`
end

#test lists
TEST_BASE_DIR="/home/compiler/test/"
ALL_TESTS=["fmm", "spec", "spec95X"]
FULL_TESTS=["fmm", "spec", "spec95X/applu"]
QUICK_TESTS=["fmm", "spec/matrix300"]
SPEC95_TESTS=["spec95X"]
MAC_TESTS=["fmm", "spec/doduc", "spec/fpppp", "spec/matrix300", "spec95X/applu"]
DEBUG_TESTS=["fmm/urand"]

#PARSE COMMAND LINE ARGUMENTS
chow_args = "-r32 -p"
selected_tests = QUICK_TESTS
opts = 
OptionParser.new do |opt|
  opt.banner = "usage: rt [options]\nRun tests for the chow allocator"
  opt.separator ""
  #arguments passed to the chow allocator
  opt.on("-c ARGS", "--chow-args ARGS", Array, 
          "Arguments passed to the chow allocator") do |list|
    chow_args = list.join(" ")
  end

  opt.on("-t TEST","--tests TEST", [:quick, :full, :spec95,:all,:debug],
                "Select test type (quick, full, spec95,all)") do |t|
    case t 
      when :quick 
        selected_tests = QUICK_TESTS
      when :full  
        selected_tests = FULL_TESTS
      when :spec95
        selected_tests = SPEC95_TESTS
      when :all
        selected_tests = ALL_TESTS
      when :debug
        selected_tests = DEBUG_TESTS
      else raise "bad test option"
    end
  end
#  opt.on("-l=LOG_FILE", "--logfile=LOG_FILE",
#        "Set the log file for the server") {|f|
#    $logfile = f
#  }
  opt.on("-d", "--debug-tests", "Run debug set of tests") {
        selected_tests = DEBUG_TESTS
  }
  opt.on("-q", "--quick-tests", "Run quick set of tests") {
        selected_tests = QUICK_TESTS
  }
  opt.on("-f", "--full-tests", "Run full (almost) set of tests") {
        selected_tests = FULL_TESTS
  }
  opt.on("-m", "--mac-tests", "Run tests known to work on mac os x"){
        selected_tests = MAC_TESTS
  }
end
begin
  opts.parse!
rescue 
  puts opts.help
  exit
end


#BEGIN SCRIPT HEADER
HEADER=<<HEADER
#!/bin/env bash
TMPDIR=scratch
CHOW=`pwd`/chow
CLEAVE=`pwd`/cleave
SPLIT_EDGES=-"{`pwd`/splitE}"
FIX_UNDEF=-"{`pwd`/fix_undef}"
DEAD=-d
VALNUM=-v
LAZY=-z
CPROP=-c
GVAL="-g[-p]"
COALESCE=-s
CLEAN=-n

HEADER
#END SCRIPT HEADER
PRE_OPT_PASSES="$DEAD $VALNUM $GVAL $LAZY $CPROP $COALESCE $DEAD"
POST_OPT_PASSES="$CLEAN"
CHOW="$CHOW"

#generate the strings for the tests
tests = selected_tests.map do |t| 
  "ctest #{TEST_BASE_DIR+t} #{PRE_OPT_PASSES}"+
        " -\"{#{CHOW} #{chow_args}}\" #{POST_OPT_PASSES}"
end

# BEGIN SCRIPT BODY
script = HEADER
script += <<BODY
mkdir $TMPDIR 2>/dev/null
pushd $TMPDIR 2>/dev/null

#{tests.join("\n")}

popd 2>/dev/null
BODY

#puts script

#write the script file
SCRIPT_FILE = "./testChow"
File.open(SCRIPT_FILE, "w+") do |f|
  f.puts(script)
end
FileUtils.chmod 0755, SCRIPT_FILE

#run tests
errors = ""
tms = Benchmark.measure do
  errors = sh SCRIPT_FILE
end

puts "================== SUMMARY ======================"
puts ("tests completed in %.0f minutes %.2f seconds" % 
      [(tms.real/60), ((tms.real) % 60)])
puts "ran tests: "+(selected_tests.join(" "))
puts "CHOW ARGS: #{chow_args}"
puts ""
errorMsgs = errors.grep(/ERROR/)
if errorMsgs == [] then puts "NO ERRORS DETECTED :)"
else puts "THERE WERE SOME ERRORS :("; puts errorMsgs.join() end
puts "================ END SUMMARY ===================="

